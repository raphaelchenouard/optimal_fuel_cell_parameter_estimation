import numpy as np
import plotly.graph_objects as go

import json
import sys
import re

class PEMFC:
    """Basic class for Proton Exchange Membrane Fuel Cell (PEMFC) definition"""
    def __init__(self,name,N_s,A,l,J_max=None,I_max=None,V_max=None):
        assert J_max!=None or I_max!=None, "Missing characteristic J_max or I_max"
        self.name = name
        # Fixed characteristics
        self.N_s = N_s # Number of cells in series
        self.A = A # membrane area (cm2)
        self.l = l # membrane thickness (cm)
        self.J_max = J_max # maximum current density (A/cm2) = I_max/A
        if I_max is None:
            self.I_max = J_max*A
        else:
            self.I_max = I_max # maximum current (A)

        # Modeling attributes
        self.parameters = None # Parameters for the model function

        # Experimental data
        self.T = None     # Temperature for experimental data (K)
        self.P_O_2 = None # O_2 pressure
        self.P_H_2 = None # H_2 pressure
        self.V_exp = None # array of measured voltage (V)
        self.I_exp = None # array of measured current (A)

    def __repr__(self):
        return "PEMFC " + self.name + "(" + str(self.N_s) + "," + str(self.A) + "," + str(self.l) + ")"

    def set_parameters(self,ksi_1,ksi_2,ksi_3,ksi_4,R_C,lamda,beta):
        self.parameters=[ksi_1,ksi_2,ksi_3,ksi_4,R_C,lamda,beta]

    def set_experimental_conditions(self,T,P_O_2,P_H_2):
        self.P_O_2 = np.array(P_O_2) if isinstance(P_O_2,list) else P_O_2
        self.P_H_2 = np.array(P_H_2) if isinstance(P_H_2,list) else P_H_2

        self.T = np.array(T) if isinstance(T,list) else T

    def set_experimental_values(self,V,I):
        self.V_exp = np.array(V)
        self.I_exp = np.array(I)

    def V_from_I(self,I=None):
        assert not(self.parameters is None) and not(self.T is None) and not(self.P_O_2 is None) and not(self.P_H_2 is None), "Error, missing exprimental data (T,P_O_2,P_H_2) and/or no parameters!"

        if I is None:
                I=self.I_exp

        T = self.T
        P_O_2 = self.P_O_2
        P_H_2 = self.P_H_2
        C_O_2 = (P_O_2/5.08e6)*np.exp(498.15/T)
        A = self.A
        l = self.l
        J_max = self.J_max

        E_Nernst = 1.229-8.5e-4*(T-298.15)+4.3085e-5*T*(np.log(P_H_2)+0.5*np.log(P_O_2))

        ksi_1,ksi_2,ksi_3,ksi_4,R_C,lamda,beta = self.parameters

        V_act = -(ksi_1 + ksi_2*1e-3*T + ksi_3*1e-5*T*np.log(C_O_2) + ksi_4*1e-5*T*np.log(I))
        V_ohmic = I*(R_C*1e-3 + (l*(181.6*(1+0.03*I/A+0.062*(T/303)**2*(I/A)**2.5))
         		 / ((lamda-0.634-3*I/A)*np.exp(4.18*(T-303)/T)))/A
           	)
        V_con = -beta*np.log(1-(I/A)/J_max)
        V_cell = E_Nernst - V_act - V_ohmic - V_con

        return self.N_s * V_cell

    def sum_squared_error(self):
        V = self.V_from_I()
        return sum((V - self.V_exp)**2)

    def root_mean_squared_error(self):
        V = self.V_from_I()
        return (sum((V - self.V_exp)**2)/len(self.I_exp))**0.5

    def mean_absolute_error(self):
        V = self.V_from_I(self.I_exp)
        return sum(np.abs(V - self.V_exp))/len(self.V_exp)

# Read a file generated by the terminal output of ibexopt
# Example of ibexopt usage:
#   ibexopt a_model.mbx > a_res_file.txt
def parse_res(res_file):
    rfile = open(res_file)
    res_str = rfile.readlines()

    result={}
    for line in res_str:
        if re.search('x* =',line):
            start = line.find('(')
            end = line.find(')')
            values_str = line[start+1:end]
            print(values_str)
            values = values_str.split(';')
            result['ksi_1'] = float(values[0])
            result['ksi_2'] = float(values[1])
            result['ksi_3'] = float(values[2])
            result['ksi_4'] = float(values[3])
            result['R_C'] = float(values[4])
            result['lambda'] = float(values[5])
            result['beta'] = float(values[6])
    return result

# Create a graphic from the provided data
def create_plot(fc_name,x_data,y_data,x_name,y_name,labels,styles):
    fig = go.Figure()
    for x_d,y_d,lbl,style in zip(x_data,y_data,labels,styles):
        fig.add_trace(go.Scatter(
            mode=style,
            y=y_d,x=x_d,name=lbl))
    fig.update_traces(marker=dict(size=12,
                                  line=dict(width=2)),
                      selector=dict(mode='markers'))
    fig.update_traces(line={'width': 5})
    fig.update_yaxes(title=y_name,tickfont = dict(size=20),titlefont = dict(size=20),showline=True, linewidth=2, linecolor='black')
    fig.update_xaxes(title=x_name,tickfont = dict(size=20),titlefont = dict(size=20),showline=True, linewidth=2, linecolor='black')
    fig.update_layout(margin=dict(l=20, r=20, t=20, b=20))
    fig.update_layout(legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="right",
        x=0.99
    ))
    fig.update_layout(
        xaxis=dict(
            ticks='outside',
            ticklen=10
        ),
        yaxis=dict(
            ticks='outside',
            ticklen=10
        )
    )
    fig.update_layout(template="plotly_white") # ["plotly", "plotly_white", "plotly_dark", "ggplot2", "seaborn", "simple_white", "none"]
    fig.show()
    fig.write_image(fc_name+"_"+x_name+"_"+y_name+".svg")

if __name__ == '__main__':
    # Name of the fuel cell
    fc_name="250W"

    # Default dirs
    data_dir='../data/'
    res_dir='../outputs/'

    # Name of the fuel cell if an argument in the command line
    if len(sys.argv)==2:
        fc_name = sys.argv[1]

    # Open data being a JSON file
    json_file = data_dir+fc_name.lower()+".json"
    jfile = open(json_file,'r')
    json_string = jfile.read()
    jfile.close()
    print('Loading data from',json_file)
    data = json.loads(json_string)

    # Create a new fuel cell object with characteristics from the JSON data
    fc = PEMFC(name=data['name'],N_s=data['N_s'],A=data['A'],l=data['l'],J_max=data['J_max'])
    # Set experimental conditions and measured values
    fc.set_experimental_conditions(T=data['T'],P_O_2=data['P_O_2'],P_H_2=data['P_H_2'])
    fc.set_experimental_values(data['V_exp'],data['I_exp'])

    # Parse a result obtained with ibexopt
    res=parse_res(res_dir+fc_name+'.txt')
    print(res)
    # Set these parameters for the created fuel cell
    fc.set_parameters(res['ksi_1'],res['ksi_2'],res['ksi_3'],res['ksi_4'],res['R_C'],res['lambda'],res['beta'])

    # Compute and print RMSE, SSE and MAE
    print("RMSE",fc.sum_squared_error())
    print("SSE",fc.sum_squared_error())
    print("MAE",fc.mean_absolute_error())

    # Prepare data for plot
    I_plot = np.linspace(min(data['I_exp']),max(data['I_exp']),100)
    # Simulate the voltage using estimated parameters
    V_plot = fc.V_from_I(I_plot)

    create_plot(fc_name,
        [data['I_exp'],I_plot],
        [data['V_exp'],V_plot],
        'A','V',
        ['Measured','Calculated'],
        ['markers','lines'])
    create_plot(fc_name,
        [data['V_exp'],V_plot],
        [np.array(data['I_exp'])*np.array(data['V_exp']),I_plot*V_plot],
        'V','W',
        ['Measured','Calculated'],
        ['markers','lines'])
